/**
 * Copyright 2020 Amazon.com, Inc. and its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0
 * 
 * Licensed under the Amazon Software License (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 * http://aws.amazon.com/asl/
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
**/


const Alexa     = require('ask-sdk-core');
const util      = require('./util');

////DAVID'S ADDITIONS
const axios = require('axios'); 
const firebase = require('firebase');


////INSERT FIREBASECONFIG HERE

async function getNutrition(journalEntry){  
  //Need to return as promise because axios is asynchronous 
  return new Promise ( resolve => {
      axios({
          method: 'post',
          url: 'https://trackapi.nutritionix.com/v2/natural/nutrients',
          headers: {
              'Content-Type': 'application/json', 
              ///INSERT NUTRIONIX APP ID AND KEY HERE
              'x-remote-user-id': '0' 
          },
          data: {
              'query': journalEntry
          }
      })
      .then( response => {
          const nutrArray = response.data.foods;  //Array of Nutrition Objects
          var partialNutrArray = []; //empty array. The Partial Nutrition Objects will only contain SOME of the nutrition object properties. 
          
          nutrArray.forEach( nutrObject => {
              //How to subset an object's properties https://stackoverflow.com/questions/17781472/how-to-get-a-subset-of-a-javascript-objects-properties 
              const partialNutrObject = (({ food_name, brand_name, nf_calories, serving_qty, serving_unit }) => ({ food_name, brand_name, nf_calories, serving_qty, serving_unit }))(nutrObject);
              
              partialNutrArray.push(partialNutrObject);
          });
          
          resolve(partialNutrArray); 
      })
      .catch(error => {
          resolve(error.response.status); 
      })
  });
}

const writeFood = {
  canHandle(handlerInput) {
      return util.isApiRequest(handlerInput, 'writeFood');
  },
  async handle(handlerInput) {
        const apiArguments = util.getApiArguments(handlerInput);
        const servingQuantity = apiArguments.servingQuantity; 
        const servingUnit = apiArguments.servingUnit; 
        const foodName = apiArguments.food;
        var journalEntry = ""; 

        if(servingQuantity) //if servingQuantity is not undefined or 0. 
        {
            journalEntry = servingQuantity + " "; 
        }
        
        
        if(servingUnit) //if servingQuantity is not empty string
        {
            journalEntry = journalEntry + servingUnit + " "; 
        }
        
        journalEntry += foodName; 
        console.log("The journal entry is " + journalEntry);   
      
        let nutr = await getNutrition(journalEntry);
        console.log(nutr); 
        
        if(nutr === 404)
        {
            console.log("The type of the error code is " + typeof nutr); 
            console.log("API is returning empty response.")
            return {apiResponse:{}}; 
        }
        else 
        {
            console.log("Nutrionix API call succeded."); 
        }

        //ANSWER TO MY PROBLEM CAME FROM https://github.com/firebase/firebase-js-sdk/issues/859 
        //set returns a promise. So you can chain. https://firebase.google.com/docs/reference/js/firebase.database.Reference#set 
        const app = firebase.initializeApp(firebaseConfig);
        const entriesRef = firebase.database().ref('/entries');
        const autoGeneratedId = entriesRef.push().key;  
        entriesRef.child(autoGeneratedId).set({
            journalEntry: journalEntry,
            modality: "voice",
            nutrition: nutr
        }).then(() => firebase.database().goOffline())
        .then(() => firebase.auth().signOut())
        .then(() => app.delete()); 

      return {
          apiResponse: {
              name: journalEntry,
              calories: nutr[0].nf_calories
          }
      };
  }
};

async function processReadFirebase(){
    return new Promise ( resolve => {
        const app = firebase.initializeApp(firebaseConfig);
        
        //Can use 'nutrition/0/nf_calories' to sort by calories assuming each entry has only one food item. 
        
        //getting reference to most recent entry
        const topEntriesRef = firebase.database().ref('/entries/').orderByKey().limitToLast(1);
        
        topEntriesRef.once('child_added').then(snapshot => {
            console.log(snapshot.val()); 
            //console.log(snapshot.val().journalEntry);
            //console.log(snapshot.val().nutrition[0].nf_calories); 
            
            const response = {
                apiResponse: {
                name: snapshot.val().journalEntry,
                calories: snapshot.val().nutrition[0].nf_calories
                }
            }; 
            
            console.log(response); 
            
            //return response; 
            return new Promise ( resolve => {
                resolve (response); 
            });  
        })
        .then( response => {
            firebase.database().goOffline();
            
            return new Promise ( resolve => {
                resolve (response); 
            });
        })
        .then( response => {
            firebase.auth().signOut();
            
            return new Promise ( resolve => {
                resolve (response); 
            });
        })
        .then( resp => {
            app.delete(); 
            console.log("The response is type " + typeof resp); 
            //It's printing in the same format as writeFood's apiResponse
            console.log(resp); 
            resolve (resp); 
        });
    });
}


const readFood = {
  canHandle(handlerInput) {
      return util.isApiRequest(handlerInput, 'readFood');
  },
  async handle(handlerInput) {
      let resp = await processReadFirebase();
      console.log(resp); 
      return resp; 
  }
};

async function processDeleteFirebaseEntry(){
    return new Promise ( resolve => {
        const app = firebase.initializeApp(firebaseConfig);
        
        //Can use 'nutrition/0/nf_calories' to sort by calories assuming each entry has only one food item. 
        
        //getting reference to most recent entry
        const topEntriesRef = firebase.database().ref('/entries/').orderByKey().limitToLast(1);
        
        topEntriesRef.once('child_added').then(snapshot => {
            console.log(snapshot.val()); 
            //console.log(snapshot.val().journalEntry);
            //console.log(snapshot.val().nutrition[0].nf_calories); 
            
            const response = {
                apiResponse: {
                name: snapshot.val().journalEntry,
                calories: snapshot.val().nutrition[0].nf_calories
                }
            }; 
            
            console.log(response); 
            
            //topEntriesRef is type query and not type reference and therefore does not have .remove()
            //need to get the key and then put it in the reference type to call remove()
            //Source: https://stackoverflow.com/questions/51017522/firebase-cloud-function-in-javascript-remove-function-not-working   
            var lastEntryKey = '/entries/' + snapshot.key; 
            console.log(lastEntryKey); 
            firebase.database().ref(lastEntryKey).remove(); 
            
            //return response; 
            return new Promise ( resolve => {
                resolve (response); 
            });  
        })
        .then( response => {
            firebase.database().goOffline();
            
            return new Promise ( resolve => {
                resolve (response); 
            });
        })
        .then( response => {
            firebase.auth().signOut();
            
            return new Promise ( resolve => {
                resolve (response); 
            });
        })
        .then( resp => {
            app.delete(); 
            console.log("The response is type " + typeof resp); 
            //It's printing in the same format as writeFood's apiResponse
            console.log(resp); 
            resolve (resp); 
        });
    });
}

const deleteJournalEntry = {
  canHandle(handlerInput) {
      return util.isApiRequest(handlerInput, 'deleteJournalEntry');
  },
  async handle(handlerInput) {
      let resp = await processDeleteFirebaseEntry();
      console.log(resp); 
      return resp; 
  }
};


///END OF DAVID'S ADDITIONS



const FallbackIntentHandler = {
    canHandle(handlerInput) {
        const request = handlerInput.requestEnvelope.request;
        return request.type === 'IntentRequest' && request.intent.name !== 'GetFavoriteColorApiHandler' && request.intent.name !== 'RecordColorApiHandler';
    },
    handle(handlerInput) {
        const intentName = handlerInput.requestEnvelope.request.intent.name;
        console.log('In catch all intent handler. Intent invoked: ' + intentName);
        const speechOutput = "Hmm, I'm not sure. You can tell me your favorite color or ask me what your favorite color is. What would you like to do";

        return handlerInput.responseBuilder
            .speak(speechOutput)
            .reprompt(speechOutput)
            .getResponse();
    },
};

const SessionEndedRequestHandler = {
    canHandle(handlerInput) {
        return Alexa.getRequestType(handlerInput.requestEnvelope) === 'SessionEndedRequest';
    },
    handle(handlerInput) {
        // Any cleanup logic goes here.
        return handlerInput.responseBuilder.getResponse();
    }
};
// Generic error handling to capture any syntax or routing errors. If you receive an error
// stating the request handler chain is not found, you have not implemented a handler for
// the intent being invoked or included it in the skill builder below.
const ErrorHandler = {
    canHandle() {
        return true;
    },
    handle(handlerInput, error) {
        console.log(`~~~~ Error handled: ${error.stack}`);
        const speakOutput = `Sorry, I had trouble doing what you asked. Please try again.`;

        return handlerInput.responseBuilder
            .speak(speakOutput)
            .reprompt(speakOutput)
            .getResponse();
    }
};
// *****************************************************************************
// These simple interceptors just log the incoming and outgoing request bodies to assist in debugging.

const LogRequestInterceptor = {
    process(handlerInput) {
        console.log(`REQUEST ENVELOPE = ${JSON.stringify(handlerInput.requestEnvelope)}`);
    },
};

const LogResponseInterceptor = {
    process(handlerInput, response) {
        console.log(`RESPONSE = ${JSON.stringify(response)}`);
    },
};

// The SkillBuilder acts as the entry point for your skill, routing all request and response
// payloads to the handlers above. Make sure any new handlers or interceptors you've
// defined are included below. The order matters - they're processed top to bottom.
exports.handler = Alexa.SkillBuilders.custom()
    .addErrorHandlers(ErrorHandler)
    .addRequestInterceptors(LogRequestInterceptor)
    .addResponseInterceptors(LogResponseInterceptor)
    .addRequestHandlers(
        writeFood, 
        readFood, 
        deleteJournalEntry, 
        //FallbackIntentHandler,
        SessionEndedRequestHandler
    )
     .withCustomUserAgent('reference-skills/intro-to-alexa-conversations/v1')
    .lambda();

